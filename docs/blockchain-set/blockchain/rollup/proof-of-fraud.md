# Optimistic Rollup欺诈证明的实现原理

Optimistic Rollup（乐观汇总）是一种Layer 2扩展解决方案，旨在提高区块链（尤其是以太坊）的交易吞吐量和效率。Optimistic Rollup通过将大量交易批量处理并记录在Layer 2上，然后将结果定期提交到Layer 1主链来实现扩展。其核心机制之一是“欺诈证明”（Fraud Proof），用于确保Layer 2的交易是有效的和可信的。

## Optimistic Rollup的基本原理

在Optimistic Rollup中，假定所有提交到Layer 1的交易都是有效的，只有在有用户对交易的有效性提出挑战时，才进行详细的验证。这种假设减少了对链上计算资源的需求，从而提高了效率。

### 欺诈证明的工作机制

欺诈证明是Optimistic Rollup中用于检测和纠正无效交易的一种机制。以下是其工作原理：

1. **交易提交**：交易首先在Layer 2上进行处理和打包，然后将这些交易的批量结果（例如，状态根）提交到Layer 1。
2. **挑战期**：每当Layer 2的交易结果提交到Layer 1后，会有一个固定的“挑战期”（Challenge Period）。在此期间，任何人都可以对提交的交易结果提出质疑，认为其中可能存在无效或欺诈交易。
3. **欺诈证明提交**：如果有人认为某个批次中的交易是无效的，他们可以提交欺诈证明。这需要提供足够的证据（例如，具体的交易数据和状态转换）来证明某个特定的交易是无效的。
4. **验证过程**：Layer 1会验证提交的欺诈证明。如果证明成功，意味着确实存在无效交易，则该批次的交易结果会被撤销，并且系统会采取纠正措施，例如惩罚提交无效交易的验证者。
5. **奖励和惩罚**：为了激励正确的行为和惩罚恶意行为，提交有效欺诈证明的人可能会获得奖励，而提交无效交易结果的验证者可能会被罚款或削减其质押的资金。

### 优点和挑战

**优点：**

* **高效性**：通过假设交易有效性并仅在有争议时进行验证，Optimistic Rollup极大地减少了计算资源的消耗。
* **扩展性**：能够处理大量交易，提高网络的吞吐量和可扩展性。
* **安全性**：依靠Layer 1的安全性，即使Layer 2上发生错误或欺诈行为，也可以通过Layer 1的验证机制进行纠正。

**挑战：**

* **挑战期延迟**：由于需要等待挑战期结束才能最终确认交易，可能会导致一定的延迟。
* **复杂性**：欺诈证明机制的实现和验证过程较为复杂，需要精确设计以确保系统的安全性和效率。
* **激励机制**：需要精心设计奖励和惩罚机制，以确保验证者和挑战者的行为都对网络有利。



## 具体实现原理

在Optimistic中，有着**Sequencer**这个角色,它将交易在链下定序后执行再将状态及交易序列提交到链上，链上并不执行交易，只是单单记录交易和状态哈希，Sequencer是个中心化的角色，但这并不太影响OP的安全性，OP的安全性由以太坊和欺诈证明机制保证。



### 简单了解一下OP的工作流程：

1. OP用户将交易发送到定序器。
2. 定序器将交易打包定序，执行后修改OP状态，再将生成的状态哈希以及交易的序列提交到链上（以太坊等）
3. 等待被挑战，该交易在链上（以太坊等）存在一个挑战期，等待被发起欺诈证明。如果过了这段时间没有欺诈证明提交，那么这个交易将无法被回退了。

### 验证器验证过程：

1. optimistic rollup在链上（以太坊等）有一个创世状态。
2. 验证器基于创世状态，按照定序器提交到链上中的批次顺序。执行每一个批次中的交易。
3. 每执行一个批次的交易，会产生一个状态根，将状态根与定序器提交的状态根进行比对。
4. 如果产生的状态根与定序器提交的相同，则验证通过，否则开始欺诈证明流程。

### 欺诈证明流程：

首先明确链上（以太坊等）有哪些数据：

1. op的创世状态
2. 定序器提交的交易批次，包含交易的顺序等信息
3. 定序器提交的每个交易批次所产生的状态根

OP在链上（以太坊等）构建了一个执行环境:OVM.

当验证者发现交易结果不正确时，就发起欺诈证明：

1.  验证者在链上（以太坊等）发起交易，目的是证明定序器提交的交易结果存在错误。验证者发起的交易存在以下数据内容：

    1. 指明交易错误的批次
    2. 该交易批次基于哪一个前置状态执行，就提交对应状态的与该批次中交易相关状态数据，以及默克尔证明。Layer1可根据默克尔证明，来计算提交的交易所涉及的前置状态的交易数据是否正确。这样做的好处是，即验证了数据的正确性，也避免了验证者需要提交所有状态数据的情况，减少计算资源消耗。

    <figure><img src="../../../.gitbook/assets/image (20).png" alt=""><figcaption></figcaption></figure>
2. 链上（以太坊等）OP的合约就通过验证默克尔证明，与前置的状态根进行比对，正确的话就说明验证者提交的状态数据是对的。
3.  合约中的OP虚拟机，通过加载验证者提交的状态和定序器之前提交的交易序列重放交易，得出交易批次的执行结果。如果交易批次的执行结果与定序器提交的状态根不一致。则欺诈证明成功。

    1. 欺诈证明成功：定序器遭到惩罚，削减质押等。验证者获得奖励

    <figure><img src="../../../.gitbook/assets/image (21).png" alt=""><figcaption></figcaption></figure>







