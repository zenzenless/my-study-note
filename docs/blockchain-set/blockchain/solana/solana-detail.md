# Solana详解

## 历史

* 2017 年 11 月，Anatoly Yakovenko 发表了一份白皮书，描述了历史证明，这是一种在不相互信任的计算机之间保持时间的技术。
* 2018 年 2 月 13 日，Greg 开始对 Anatoly 白皮书的第一个开源实现进行原型设计。该项目在 loomprotocol 组织中以 Silk 的名义发布到 GitHub。
* 2018 年 2 月 28 日，Greg 发布了他的第一个版本。不久之后，另一位前高通团队 Stephen Akridge 证明了通过将签名验证卸载到图形处理器可以大大提高吞吐量。 Anatoly 招募了 Greg、Stephen 和其他三人共同创办了一家公司，后来称为 Loom。
* 2018 年 3 月 28 日， Loom 团队决定重新命名。他们选择了索拉纳这个名字，这是对圣地亚哥北部一个名为索拉纳海滩的小镇的致敬，**阿纳托利**、**格雷格**和**斯蒂芬**在高通公司工作时曾在那里生活和冲浪了三年。团队创建了 Solana GitHub 组织，并将 Greg 的原型 Silk **更名为 Solana**。
* 2018 年 6 月，该团队扩大了该技术以在基于云的网络上运行，并于 7 月 19 日发布了一个 50 节点、经许可的**公共测试网**，始终支持每秒 250,000 笔交易的爆发。该项目还扩展为支持用 C 编程语言编写的链上程序，并在称为 BPF 的安全执行环境中并发运行。
* 2020 年 3 月 16 日，Solana 的第一个区块被创建。

## SOL

SOL 是 `Solana` 原生代币的名称,更小单位的 `SOL` 称为 `Lamport`。他们的名字是为了纪念 Solana 对技术影响最大的 Leslie Lamport。一个`Lamport`的值为 0.000000001 SOL。&#x20;

## Solana的时间&#x20;

### 什么是POH?&#x20;

`POH`全称为`Proof of history`,它用 SHA 256 作为 Solana 的验证延迟函数（Verifiable Delay Function），它**不断的对自身**进行`hash`,以此来**证明链上时间的流逝**。

其特点是：**具有不可逆性，只能单向计算。**

<figure><img src="../../../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

可以向输入中添加其它数据，下图可以证明，插入的数据必发生在第三个哈希前。

<figure><img src="../../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

下图可以证明插入数据的时间必发生在 A 和 C 之间，且由于对数据中包含了 A 的哈希，再加上签名。可 以保证这条交易信息一定发生在 A 之后。

<figure><img src="../../../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

验证的时候可以并行验证，所以速度会很快。每个记录的切片都可以在单独的内核上从头到尾验证，所 需时间为生成时间的 1/（内核数）。因此，具有 4000 个内核的现代 GPU 可以在 0.25 毫秒内验证一 秒。

<figure><img src="../../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>



### 为什么分布式网络需要可靠的时间戳？

* 确保事务顺序的准确性：

时间对于分布式账本技术的意义不言而喻，任何账本都需要达到「有序」，人们不能花没有收到的钱，也不能花已经花了的钱。区块链技术本身必须在无需第三方的情况下，明确地对账本进行排序。虽然区块链中还有许多其他技术细节，但**时间是至关重要的，没有时间与顺序，就没有区块链**。

### 区块链中的时间

> 参考资料：[https://www.6up7.com/time-in-distributed-system/](https://www.6up7.com/time-in-distributed-system/)

区块链的设计者们深知这一点，并给时间戳留下了足够的冗余。在[比特币的block timestamp](https://en.bitcoin.it/wiki/Block\_timestamp)中，如果时间戳大于前11个区块的中值时间并小于网络调整时间+2小时，就可以被接受为有效时间。这导致比特币区块的时间戳并不完全按顺序排列。[以太坊](https://github.com/ethereum/wiki/wiki/White-Paper#mining)则明确规定区块的时间戳需要大于前一个区块且小于2小时的偏移。

区块链上**真正重要的不是时间戳，而是交易的顺序**。在一个点对点的电子现金系统中，正确性基于以下两点：

* 你不能花你还没收到的钱
* 你不能花你已经花出去的钱

一般来说，经典分布式系统处理时钟有两种方式。消息由发件人加盖时间戳并签名。节点丢弃太旧或太新的消息。此计算基于时间戳和本地时钟之间的差异。第二种方法是每个状态转换在过期之前都有一个本地超时。例如，在 Tendermint 上，**预提交状态有一秒的超时时间**。下一个区块生产者可以**尝试提议**下一个区块，但网络中的所有节点会在预提交状态转换开始后**等待至少 1 秒**，然后再考虑新的提议。

在这两种方法中，提议者的时钟都不能被信任，并且每个节点都会采取预防措施并强制延迟共识状态机的进度，以确保提议者不会作弊。尽管这些延迟对于网络安全至关重要，但它们会导致更慢的阻塞时间。

比特币的难度调整迫使网络平均大约每 10 分钟产生一次区块。以太坊难度设置为平均每 15 秒产生一次区块。两个网络之间的差异可以通过冲突或叔叔的数量来衡量。出块时间越短，两个节点同时出块的可能性就越高，而 15 秒可能是 Nakamoto 风格链出块速度的下限。



## Solana共识机制

### Solana出块机制简介

在Solana的系统架构中，最重要的角色分为两类：Leader（出块者）和Validator（验证者）。两者实际上都是质押了SOL代币的全节点，只是在不同的Slot（出块周期）内，Leader会由不同的全节点来充当，而没有当选Leader的全节点会成为Validator。

solana 中的4类角色：

* 普通用户
* SOL质押者/矿工
* 验证节点
* 领导者节点(由验证节点产生)

在每个新的Epoch周期开始时，Solana网络会按照各节点的质押权重进行抽选，组成一个出块者Leader轮换名单，“钦定”了未来不同时刻的出块者。在整个Epoch（2\~4天）内，出块者会按照名单指定的次序进行轮换，每过4个Slot（出块周期），Leader节点就会进行一次变更。

<figure><img src="../../../.gitbook/assets/image (4).png" alt=""><figcaption></figcaption></figure>

由于提前公开了未来的出块节点，Solana网络实质获得了确定而可信的新区块数据源，为共识过程提供了巨大便利，同时也带来了部分问题（也是Solana宕机的原因之一）。



### 出块流程简介

> 参考资料：[https://web3caff.com/zh/archives/14903](https://web3caff.com/zh/archives/14903)

1. 用户发起交易后，会被客户端直接转发给Leader节点，或者先被普通节点接收，再立刻转发给Leader；
2. 出块者Leader接收网络内全部的待处理交易，一边执行，一边给交易指令排序，制成交易序列（类似区块）。每隔一段时间，Leader会把排好的交易序列发送给Validator验证节点；

<figure><img src="../../../.gitbook/assets/image (6).png" alt=""><figcaption></figcaption></figure>

1. Validator按照交易序列（区块）给定的顺序执行交易，产生相应的状态信息State（执行交易会改变节点的状态，比如改变某些账户的余额）；
2. 每发送N个交易序列，Leader会定期公开本地的状态State，Validator会将其与自己的State作对比，给出 肯定/否定 的投票。这一步就类似于以太坊2.0或其他POS公链里的“检查点”。

<figure><img src="../../../.gitbook/assets/image (7).png" alt=""><figcaption></figcaption></figure>

5. 如果在规定时间内，Leader收集到占全网 2/3质押权重 的节点们给出的肯定票，则此前发布的交易序列和状态State就被敲定，“检查点”通过，相当于区块完成最终确认Finality；
6. 一般而言，给出肯定票的Validator节点与出块者Leader所执行的交易、执行后的状态都是相同的，数据会同步。
7. 每过4个Slot周期，Leader会进行一次切换，这意味着Leader每次大概有1.6秒\~3.2秒时间掌握网络的“最高话语权”。

以上就是Solana出块流程的简单概括，当然，只是看出块流程还是很难想象为什么Solana能有如此高的TPS。

### 高TPS的原因

#### 同步

快速、可靠的同步是Solana能够实现如此高吞吐量的最大原因。传统的区块链在被称为区块的大块交易上进行同步。区块打包交易时消耗的时间，我们称之为`区块打包时间`，只有在区块打包完成时，才能确定交易执行顺序，各个节点才能在同一个区块上生成同样的状态。

* **工作证明：像一般的工作证明机制，生成区块的时间较长，像是比特币（约10分钟）、以太坊（约12秒），如果缩短出块时间，就会增大不同矿工在同一时间出块**的概率。
*   **权益证明**：在权益证明中，需要可靠的时间戳，才能确定区块的顺序。否则出块节点提前出块，验证节点无法确认是自己的时间戳慢还是说`块`提前发出了。或者说，出块节点延迟出块，过段时间再把区块给补上，验证节点无法确认是自身网络延迟或者节点延迟出块。

    > 一般来说，经典分布式系统处理时钟有两种方式。消息由发件人加盖时间戳并签名。节点丢弃太旧或太新的消息。此计算基于时间戳和本地时钟之间的差异。第二种方法是每个状态转换在过期之前都有一个本地超时。
    >
    > 例如，在 Tendermint 上，预提交状态有一秒的超时时间。下一个区块生产者可以尝试提议下一个区块，但网络中的所有节点会在预提交状态转换开始后至少等待 1 秒，然后再考虑新的提议。

    * 举个例子：在`COSMOS HUB`中，每个区块的产生时间约为6秒，在这段时间内，验证者必须等待提议者打包完成交易消息，然后验证者再对区块中的消息进行执行验证，生成下一个区块的前置状态。如果当前所轮到的提议者离线或超时，则由下一轮的提议者出块。在这个过程中，`COSMOS` **在区块上标记了一个时间戳，验证者通过对比区块上的时间戳来确定下一个区块的提议者是否已经超时。由于时钟漂移和网络延迟的变化，时间戳只在一两个小时内准确。** 验证者之间的系统时间并不完全相同，为了解决这个问题，这些系统延长了块的时间，以提供合理的确定性。如果想要**通过缩短出块时间来提高**`TPS`，就会因为时间同步问题，**导致产生很多分叉**(超时时间变短了)。

<figure><img src="../../../.gitbook/assets/image (8).png" alt=""><figcaption></figcaption></figure>

大部分区块链需要保持集群内时间同步，然而网络延迟不可避免，当出块间隔越小时，网络延迟的影响越大。

Solana 采用了一种不同寻常的方法，利用历史证明或称之为POH，解决分布式系统的时间戳问题。POH能够证明已经流逝了这么多的时间。每个验证器都一直在本地跑着POH，这样就无需网络同步也能估算出整个Solana网络中时间的流逝。

而且，所有添加到历史证明中的数据，肯定是在证明生成前发生的。于是solana节点能够知道区块的产生顺序，区块可以以任何顺序到达验证节点。Solana还将区块分解成更小的交易批次，称之为条目，条目是在区块形成之前，实时流向验证节点的。

来看以下两个例子

* 在`Filecoin`中，如果节点收到一个来自`未来`的区块，要么是挖出该区块的矿工提前出块，要么是该节点的系统时间比其它集群慢。此时`lotus`会将该区块丢弃，如果错误原因是后者，则节点将会与网络失去同步。产生这个问题的主要原因是`lotus`的时间与其它节点不同步，区块自身无法证明其时间有效性。
* 在`Filecoin`中，是先将消息打包进入区块内，再执行区块内的消息，链状态才发生改变。区块之间的产生间隔是`30秒`，前6秒用于等待上一个区块的网络传播，后面24秒用于打包交易并发布区块。在这`30秒`中，非出块节点把大部分时间都花在了等矿工出块上，验证新区块及更新节点状态花费的时间较少。`Solana`将区块内交易分解成多个小批次，边打包交易边传播，当区块打包完成时，验证节点刚好执行完区块中的交易。

<figure><img src="../../../.gitbook/assets/image (9).png" alt=""><figcaption></figcaption></figure>

可以看到，大部分时间用于等待区块的网络传播，真正开始进行状态转换的时间占比并不多。

所以Solana为了利用起网络传播所消耗的时间，做了一点优化。想象一下，如果我们在网上下载一部电影，等电影下载完了再去观看，那么需要的时间就是 “下载时间+观看时间” ，但是如果我们是采用“边下边播”的模式呢？

<figure><img src="../../../.gitbook/assets/image (10).png" alt=""><figcaption></figcaption></figure>

#### POH同步的优势在于

* 传统的区块链在生成下一个区块时，全局状态会被锁定，但POH可以避免这种情况
* 解决时间同步问题

### Tower BFT

TODO

